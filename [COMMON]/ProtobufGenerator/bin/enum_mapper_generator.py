#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import sys
import os
from pathlib import Path

def parse_proto_files(proto_dir):
    """
    proto 파일에서 packet_number enum 파싱
    """
    packet_number_map = {}
    
    print(f"Scanning directory: {os.path.abspath(proto_dir)}")
    proto_files = list(Path(proto_dir).rglob("*.proto"))
    
    print(f"Found {len(proto_files)} .proto files:")
    for pf in proto_files:
        print(f"  - {pf}")
    
    if not proto_files:
        print("ERROR: No .proto files found!")
        return packet_number_map
    
    for proto_file in proto_files:
        print(f"\nParsing: {proto_file}")
        with open(proto_file, 'r', encoding='utf-8') as f:
            content = f.read()
            
            # packet_number enum 찾기
            enum_pattern = r'enum\s+packet_number\s*\{([^}]+)\}'
            enum_match = re.search(enum_pattern, content, re.MULTILINE | re.DOTALL)
            
            if enum_match:
                print("  ✓ Found packet_number enum")
                enum_body = enum_match.group(1)
                
                # 각 항목 파싱
                item_pattern = r'(\w+)\s*=\s*(\d+)\s*;'
                items = re.findall(item_pattern, enum_body)
                
                print(f"  Found {len(items)} enum values:")
                for name, number in items:
                    if name != "NONE":
                        packet_number_map[name] = int(number)
                        print(f"    {name} = {number}")
            else:
                print("  ✗ No packet_number enum found in this file")
    
    return packet_number_map

def generate_cpp_mapper(packet_number_map, output_path):
    """
    C++ 매퍼 헤더 생성
    """
    content = """// Auto-generated by enum_mapper_generator.py
// DO NOT EDIT THIS FILE MANUALLY

#pragma once
#include <string>
#include <unordered_map>
#include <stdexcept>

class PacketNumberMapper {
public:
    // 메시지 타입명에서 protocol number 추출
    // 예: "C2S_TestEcho" → 1
    static unsigned short GetProtocolNumber(const std::string& message_type_name) {
        // "_" 뒤의 packet_number 이름 추출
        size_t pos = message_type_name.find('_');
        if (pos == std::string::npos) {
            throw std::invalid_argument("Invalid message type name: " + message_type_name);
        }
        
        std::string packet_name = message_type_name.substr(pos + 1);
        
        static const std::unordered_map<std::string, unsigned short> name_to_number = {
"""
    
    for name, number in sorted(packet_number_map.items(), key=lambda x: x[1]):
        content += f'            {{"{name}", {number}}},\n'
    
    content += """        };
        
        auto it = name_to_number.find(packet_name);
        if (it != name_to_number.end()) {
            return it->second;
        }
        throw std::invalid_argument("Unknown packet name: " + packet_name);
    }
    
    // protocol number → 이름
    static const char* GetPacketName(unsigned short protocol_number) {
        static const std::unordered_map<unsigned short, const char*> number_to_name = {
"""
    
    for name, number in sorted(packet_number_map.items(), key=lambda x: x[1]):
        content += f'            {{{number}, "{name}"}},\n'
    
    content += """        };
        
        auto it = number_to_name.find(protocol_number);
        if (it != number_to_name.end()) {
            return it->second;
        }
        return "UNKNOWN";
    }
};
"""
    
    output_dir = os.path.dirname(output_path)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"\n✓ Generated C++: {os.path.abspath(output_path)}")

def generate_csharp_mapper(packet_number_map, output_path):
    """
    C# 매퍼 클래스 생성
    """
    content = """// Auto-generated by enum_mapper_generator.py
// DO NOT EDIT THIS FILE MANUALLY

using System;
using System.Collections.Generic;

public static class PacketNumberMapper
{
    private static readonly Dictionary<string, ushort> NameToNumber = new Dictionary<string, ushort>
    {
"""
    
    for name, number in sorted(packet_number_map.items(), key=lambda x: x[1]):
        content += f'        {{ "{name}", {number} }},\n'
    
    content += """    };

    private static readonly Dictionary<ushort, string> NumberToName = new Dictionary<ushort, string>
    {
"""
    
    for name, number in sorted(packet_number_map.items(), key=lambda x: x[1]):
        content += f'        {{ {number}, "{name}" }},\n'
    
    content += """    };

    /// <summary>
    /// 메시지 타입명에서 protocol number 추출
    /// 예: "C2S_TestEcho" → 1
    /// </summary>
    public static ushort GetProtocolNumber(string messageTypeName)
    {
        // "_" 뒤의 packet_number 이름 추출
        int pos = messageTypeName.IndexOf('_');
        if (pos == -1)
        {
            throw new ArgumentException($"Invalid message type name: {messageTypeName}");
        }
        
        string packetName = messageTypeName.Substring(pos + 1);
        
        if (NameToNumber.TryGetValue(packetName, out ushort number))
        {
            return number;
        }
        
        throw new ArgumentException($"Unknown packet name: {packetName}");
    }

    /// <summary>
    /// protocol number에서 패킷 이름 추출
    /// </summary>
    public static string GetPacketName(ushort protocolNumber)
    {
        if (NumberToName.TryGetValue(protocolNumber, out string name))
        {
            return name;
        }
        
        return "UNKNOWN";
    }

    /// <summary>
    /// 제네릭 타입에서 protocol number 추출
    /// </summary>
    public static ushort GetProtocolNumber<T>()
    {
        return GetProtocolNumber(typeof(T).Name);
    }
}
"""
    
    output_dir = os.path.dirname(output_path)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"✓ Generated C#: {os.path.abspath(output_path)}")

def main():
    if len(sys.argv) < 4:
        print("Usage: python enum_mapper_generator.py <proto_dir> <cpp_output> <csharp_output>")
        print("Example: python enum_mapper_generator.py ./proto ./PacketNumberMapper.h ./PacketNumberMapper.cs")
        sys.exit(1)
    
    proto_dir = sys.argv[1]
    cpp_output = sys.argv[2]
    csharp_output = sys.argv[3]
    
    print("="*60)
    print("Packet Number Mapper Generator")
    print("="*60)
    
    if not os.path.exists(proto_dir):
        print(f"ERROR: Proto directory not found: {proto_dir}")
        sys.exit(1)
    
    packet_number_map = parse_proto_files(proto_dir)
    
    if not packet_number_map:
        print("\nERROR: No packet_number enum found in any .proto file!")
        print("Make sure your .proto file contains:")
        print("  enum packet_number {")
        print("      NONE = 0;")
        print("      TestEcho = 1;")
        print("  }")
        sys.exit(1)
    
    print(f"\n{'='*60}")
    print(f"Total: {len(packet_number_map)} packet numbers found")
    print(f"{'='*60}")
    
    generate_cpp_mapper(packet_number_map, cpp_output)
    generate_csharp_mapper(packet_number_map, csharp_output)
    
    print("\n✓ Code generation completed successfully!")
    print("="*60)

if __name__ == "__main__":
    main()